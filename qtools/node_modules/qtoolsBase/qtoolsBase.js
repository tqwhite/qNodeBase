'use strict';

var events = require('events'),
	util = require('util'),
	fs = require('fs');

//START OF moduleFunction() ============================================================
var moduleFunction = function(self) {

	//remember, this is instantiated by qtools.js

	//INITIALIZATION ====================================
	events.EventEmitter.call(this);
	self.forceEvent = function(eventName, outData) {
		self.emit(eventName, {
			eventName: eventName,
			data: outData
		});
	}

	var self = self;
	var qtools = self;

	var delimitterHeavy = "========================================================",
		delimitterLight = "--------------------------------------------------------",
		topDelim = "\n\n" + delimitterLight + "\n\n",
		bottomDelim = "\n\n" + delimitterHeavy + "\n\n";


	//LOCAL FUNCTIONS ====================================


	//BUILD OBJECT ====================================

	self.colors = require('colors'); //bold, italic, underline, inverse, yellow, cyan, white, magenta, green, red, grey, blue, rainbow, zebra, random

	self.delimitter = delimitterHeavy; //sometimes it's convenient to be able to use this from outside
	self.topDelim = delimitterHeavy;
	self.bottomDelim = delimitterLight;

	self.wrapMessage = function(message) {
		return "\n\n" + delimitterLight + "\n\n" + message + "\n\n" + delimitterHeavy + "\n\n";
	}

	self.hash = function(inData) {
		if (!this.md5) {
			this.md5 = require('MD5');
		}

		var string = inData;

		if (inData == null) {
			string = 'null'
		} else if (typeof (inData) == 'object') {
			string = JSON.stringify(inData);
		}
		var hash = self.md5(string);

		return hash;
	}

	self.uniqueId = Math.floor(Math.random() * 100000);

	self.newGuid = function() {
		//thanks 'broofa': http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript
		return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
			var r = Math.random() * 16 | 0,
				v = c == 'x' ? r : (r & 0x3 | 0x8);
			return v.toString(16);
		}).toLowerCase();
	}

	self.dump = function(inData, returnStringFlag) {
		returnStringFlag = returnStringFlag ? returnStringFlag : false;

		if (returnStringFlag) {
			return util.inspect(inData, {depth:null});
		} else {
			console.log('\n'+util.inspect(inData, {depth:null})+'\n');
		}
	}
	
	self.dumpToFile=function(inData, filePath, fileOptions){

		var outString=self.dump(inData, true);
		if (fileOptions.addSeparator){
			outString=self.wrapMessage(outString);
		}
		
		self.writeSureFile(filePath, outString, fileOptions);
	}


	self.addSpaces = function(inString, desiredLength, fillChar) {
		fillChar = fillChar ? fillChar : ' ';
		var len = inString.length,
			remainder = Math.ceil((desiredLength - len) / fillChar.length),
			outString = inString;

		for (var i = 0; i < remainder; i++) {
			outString += fillChar;
		}
		return outString;

	}

	self.dumpFlat = function(inData, returnStringFlag, filterList) {
		if (typeof (returnStringFlag) != 'string') {
			returnStringFlag = returnStringFlag ? returnStringFlag : false;
		}

		var dottedPathList = qtools.extractDottedPaths(inData),
			outString = '';

		if (typeof (returnStringFlag) == 'string') {
			console.log('\n\nSTART ' + returnStringFlag + ' ' + delimitterHeavy);
		}

		var maxNameLength = 0;
		for (var i = 0, len = dottedPathList.length; i < len; i++) {
			var element = dottedPathList[i],
				len2 = element.length,
				maxNameLength = (len2 > maxNameLength) ? len2 : maxNameLength;
			if (len2 > maxNameLength) {
				var last = element;
			}
		}
		maxNameLength = maxNameLength + 5;

		for (var i = 0, len = dottedPathList.length; i < len; i++) {
			var element = dottedPathList[i],
				violatesFilter = false;

			if (filterList) {
				violatesFilter = true
				for (var j = 0, len2 = filterList.length; j < len2; j++) {
					if (element.match(new RegExp(filterList[j]))) {
						violatesFilter = false;
						break;
					}
				}
			}

			if (violatesFilter) {
				continue;
			}

			var value = qtools.getSurePath(inData, element);

			outString += self.addSpaces(element, maxNameLength, '.') + ' ' + value;

			if (!returnStringFlag || typeof (returnStringFlag) == 'string') {
				console.log(outString);
				outString = '';
			}



		}


		if (typeof (returnStringFlag) == 'string') {

			if (typeof (returnStringFlag) == 'string') {
				console.log('END ' + returnStringFlag + ' ' + delimitterLight + '\n\n');
			}
		} else if (returnStringFlag) {
			return outString;
		}
	}


	self.removeNullElements = function(target, removeFalsy, keepFunction) {

		removeFalsy = !(typeof (removeFalsy) == 'undefined' || removeFalsy === '' || removeFalsy === false); //ie, any non-false value says removeFalsy values
		if (typeof (keepFunction) == 'undefined') {
			keepFunction = function(element, removeFalsy) {
				return (element || (removeFalsy && (typeof (element) == 'boolean' || typeof (element) == 'integer')));
			}
		}


		if (typeof (target) == 'object' && typeof (target.length) != 'undefined') {
			var outArray = [],
				inx = 0;
			for (var i = 0, len = target.length; i < len; i++) {
				var element = target[i];
				if (keepFunction(element, removeFalsy)) {
					outArray[inx] = element;
					inx++
				}
			}
			return outArray;
		} else if (typeof (target) == 'object') {
			var outObj = {};
			for (var i in target) {
				var element = target[i];
				if (keepFunction(element, removeFalsy)) {
					outObj[i] = element;
				}
			}

			return outObj;
		} else {
			throw "qtoolsBase.removeNulls() says, 'target must be object or array'";
		}
	}

	self.getByProperty = function(inArray, propertyName, propertyValue) {
		var len = inArray.length,
			inx = 0;
		for (inx = 0; inx < len; inx++) {
			if (self.getSurePath(inArray[inx], propertyName) == propertyValue) {
				return inArray[inx];
			}
		}
		return null;
	}


	self.getIndexByValue = function(inObject, propertyValue, dottedSubPath) {
		//qtools.getIndexByValue(self.dataSource.tmp, "z", 'inner.val');
		for (var i in inObject) {
			var element = inObject[i];
			if (typeof (dottedSubPath) != 'undefined') {
				element = qtools.getSurePath(element, dottedSubPath);
			}

			if (element === propertyValue) {
				return i;
			}
		}

	}

	// 	self.clone = function(inData) {
	// 		return JSON.parse(JSON.stringify(inData));
	// 	}

	self.isEmpty = function(arg) {
		var objectEmptyFlag;

		if (typeof (arg) == 'function') {
			return false;
		}

		if (typeof (arg) == 'undefined') {
			return true;
		}

		if (typeof (arg) == 'object') {
			objectEmptyFlag = true; //assume it's empty until further notice
			for (var item in arg) {
				objectEmptyFlag = false; //found one
			}
		} else {
			objectEmptyFlag = false; //can't be full if it's not an object
		}

		return (objectEmptyFlag || arg == '' || arg.length == 0)
	}

	self.isNotEmpty = function(arg) {
		return !self.isEmpty(arg);
	}

	self.die = function(exceptionData) {
		switch (exceptionData) {
			case 'silent':
				process.exit(1);
				break;
			case 'trace': //stack
				console.log("\n\n================================\n");
				console.trace();
				console.log("\n================================\n\n");
				process.exit(1);
				break;
			default:
				var prefix = this.employerFilename ? this.employerFilename : 'qtools.die()';
				var outObj = {};

				if (exceptionData) {
					prefix = prefix + " says";
					outObj[prefix] = exceptionData
					this.dump(outObj);
				} else {
					console.log(topDelim + 'Exiting ' + prefix + ' via qtools.die()' + bottomDelim);
				}
				process.exit(1);
				break;
		}
	}
	
	self.errorExit=function(exceptionData){
		var outMessage;
		if (typeof(exceptionData)!='string'){
			outMessage=self.dump(exceptionData, true);
		}
		else{
			outMessage=exceptionData;
		}
		
		process.stderr.write(outMessage);
		process.exit(1);
	}
	
	self.successExit=function(exceptionData){
		if (exceptionData){
			var outMessage='';
			if (typeof(exceptionData)!='string'){
				outMessage=self.dump(exceptionData, true);
			}
			process.stderr.write(outMessage);
		}
		process.exit(0);
	}

	self.message = function(messageData, color, longFilename) {
		if (typeof (console) == 'undefined') {
			return;
		}
		if (typeof (longFilename) == 'undefined') {
			longFilename = false;
		}
		var prefix = '\n**==*: ',
			suffix = longFilename ? ' (' + __dirname + '/' + this.employerFilename + ')\n' : ' (' + this.employerFilename + ')\n',
			message;
		if (typeof (messageData) == 'string') {
			message = prefix + messageData + suffix;
			if (color) {
				console.log(message[color].bold);
			} else {
				console.log(message.red.bold);
			}
			return;
		}
	}

	self.byObjectProperty = function(fieldName, transformer) {
		//called: resultArray=someArray.sort(qtools.byObjectProperty('somePropertyName'));
		//based on closure of fieldName
		var fullNameSort;
		return fullNameSort = function(a, b) {
			var localFieldName = fieldName, //for debug
				localTransformer = transformer; //for debug

			if (typeof (fieldName) == 'function') {
				var aa = a,
					bb = b;
				var transformer = fieldName;
			} else {
				var aa = qtools.getSurePath(a, fieldName),
					bb = qtools.getSurePath(b, fieldName);
			}

			if (typeof (transformer) == 'function') {
				aa = transformer(aa);
				bb = transformer(bb);
			} else if (transformer) {
				switch (transformer) {
					case 'caseInsensitive':
						aa = aa.toLowerCase();
						bb = bb.toLowerCase();
						break;
					default:
						qtools.consoleMessage('qtools.byObjectProperty says, No such transformer as: ' + transformer);
						break;
				}
			}

			if (!bb && !aa) {
				return 0;
			}
			if (!bb) {
				return -1;
			}
			if (!aa) {
				return 1;
			}

			if (aa > bb) {
				return 1;
			}
			if (aa < bb) {
				return -1;
			}
			return 0;
		}
	},

	self.listProperties = function(inObject, toString) {
		if (typeof (toString) == 'undefined') {
			toString = false;
		}
		var outString = '';
		var list = [];
		var count = 0;
		var type = qtools.toType(inObject);

		if (type == 'object' || type == 'arguments') {
			var outList = [];
			for (var i in inObject) {
				var element = inObject[i],
					showElement;

				if (['object', 'array', 'function'].indexOf(qtools.toType(element)) == -1) {
					if (element == null) {
						showElement = 'null'.green;
					} else {
						showElement = element.toString().green;
					}

					outList.push({
						name: i,
						string: ('item #' + count + ' named \'').grey + i.red + '\' is a '.grey + qtools.toType(element).red + ' value= '.grey + showElement
					});
				} else {
					outList.push({
						name: i,
						string: ('item #' + count + ' named \'').grey + i.red + '\' is a '.grey + qtools.toType(element).red
					});
				}
				count++;
			}

			outList = outList.sort(qtools.byObjectProperty('name'));

			for (var i = 0, len = outList.length; i < len; i++) {
				var element = outList[i];

				if (!toString) {
					console.log(element.string);
				} else {
					outString += element.string + '\n';
				}
			}

		} else if (type == 'array') {

			for (var i = 0, len = list.length; i < len; i++) {
				var element = inObject[i];

				if (!toString) {
					console.log('item #' + count + ' index \'' + i + ' is ' + qtools.toType(element));
				} else {
					outString += 'item #' + count + ' index \'' + i + ' is ' + qtools.toType(element) + '\n';
				}
				count++;
			}
		}

		return outString;
	}

	self.toType = function(obj) {
		if (obj === null) {
			return 'null';
		} else if (typeof (obj) == 'undefined') {
			return 'undefined';
		} else {
			return ({}).toString.call(obj).match(/\s([a-z|A-Z]+)/)[1].toLowerCase();
		}
	} //thanks: http://javascriptweblog.wordpress.com/2011/08/08/fixing-the-javascript-typeof-operator/

	self.errorObject = function(message, evidence) {
		var outObj = {};
		outObj.message = message;
		outObj.evidence = evidence;
		return outObj;
	}

	self.displayJson = function(inObject) {
		var jsonString = JSON.stringify(inObject);
		console.log(self.wrapMessage(jsonString));
	}

	self.validateProperties = function(args) {

		/*
				qtools.validateProperties({
					subject:args,
					targetScope: this, //will add listed items to targetScope
					propList:[
						{name:'parent', optional:true, requiredType:'', assertNotEmptyFlag:false}
					]
				});
				
		*/
		var name, type, notEmpty, element, importance, optional,
			outList = [],
			outMessage = '',
			inObj = args.subject,
			propList = args.propList,
			source = args.source ? args.source : self.employerFilename,
			importance = args.importance,
			optional = args.optional,
			targetScope = args.targetScope ? args.targetScope : '';


		if (self.toType(targetScope) != 'object') {
			targetScope = false;
		}

		source = source ? source + ' (via qtools.validateProperties) ' : 'qtools.validateProperties ';

		for (var i = 0, len = propList.length; i < len; i++) {
			var name = propList[i].name,
				importance = propList[i].importance,
				optional = propList[i].optional,
				requiredType = propList[i].requiredType ? propList[i].requiredType : false,
				assertNotEmptyFlag = propList[i].assertNotEmptyFlag,
				element = inObj[name];

			if ((!optional && importance != 'optional') && typeof (element) == 'undefined') {
				outList.push(name + ' is missing');
			}

			if (requiredType && self.toType(element) != requiredType) {
				outList.push(name + ' is not of type ' + requiredType);
			}
			if (assertNotEmptyFlag && self.isEmpty(element)) {
				outList.push(name + ' cannot be empty');
			}

			if (targetScope) {
				targetScope[name] = inObj[name];
			}
		}


		for (var i = 0, len = outList.length; i < len; i++) {
			outMessage += outList[i] + '\n';
		}

		if (outMessage) {
			console.log(self.wrapMessage(source + ' says, \n\n' + outMessage));
			self.die('silent');
		}

	}

	//jQUERY here. From https://github.com/jquery/jquery/blob/master/src/core.js#L390
	//call: self.extend(baseObject, extensionObject);
	self.extend = function() {
		var options, name, src, copy, copyIsArray, clone,
			target = arguments[0] || {},
			i = 1,
			length = arguments.length,
			deep = false;

		// Handle a deep copy situation
		if (typeof target === "boolean") {
			deep = target;

			// skip the boolean and the target
			target = arguments[i] || {};
			i++;
		}

		// Handle case when target is a string or something (possible in deep copy)
		if (typeof target !== "object" && !typeof (target) == 'function') {
			target = {};
		}

		// extend jQuery itself if only one argument is passed
		if (i === length) {
			target = self;
			i--;
		}

		for (; i < length; i++) {
			// Only deal with non-null/undefined values
			if ((options = arguments[i]) != null) {
				// Extend the base object
				for (name in options) {
					src = target[name];
					copy = options[name];

					// Prevent never-ending loop
					if (target === copy) {
						continue;
					}

					// Recurse if we're merging plain objects or arrays
					if (deep && copy && (typeof (copy) == 'object' || (copyIsArray = (typeof (copy.length) != 'undefined')))) {
						if (copyIsArray) {
							copyIsArray = false;
							clone = src && (typeof (src.length) != 'undefined') ? src : [];

						} else {
							clone = src && (typeof (src) == 'object') ? src : {};
						}

						// Never move original objects, clone them
						target[name] = self.extend(deep, clone, copy);

						// Don't bring in undefined values
					} else if (copy !== undefined) {
						target[name] = copy;
					}
				}
			}
		}

		// Return the modified object
		return target;
	};

	self.count = function(inData) {
		if (typeof (inData) == 'undefined') {
			return;
		}
		var type = self.toType(inData),
			outValue;
		switch (type) {
			case 'array':
				outValue = inData.length;
				break;
			case 'object':
				outValue = 0;
				for (var i in inData) {
					outValue++;
				}
				break;
			default:
				if (inData.hasOwnProperty('length') != 'undefined') {
					outValue = inData.length;
			}
		}

		return outValue;
	}

	self.getOnlyProperty = function(inObject) {
		var count = 0;
		for (var i in inObject) {
			var element = inObject[i];
			count++;
		}
		if (count != 1) {
			qtools.die(qtools.errorObject("qtools.getOnlyProperty() says, object must have exactly one property", inObject));
		}
		return element;
	}

	self.copySureFile = function(destFilePath, sourceFilePath) {
		//copies the file after creating all the intermediate paths

		var returnObj = {
			createdDirectories: []
		};

		if (!fs.existsSync(sourceFilePath)) {
			qtools.message('ERROR: *** file does NOT EXIST: ' + sourceFilePath + ' ***');
			return -1;
		}


		var destFilePathElementArray = destFilePath.split('/'),
			workingPath = '';

		for (var i = 0, len = destFilePathElementArray.length - 1; i < len; i++) {
			var element = destFilePathElementArray[i].replace(/[\#\ \<\$\+\%\>\!\`\&\*\‘\|\{\?\“\=\}\:\\\@]+/g, ''); //allows / character

			workingPath += element + '/';

			if (fs.existsSync(workingPath)) {
				continue;
			}

			fs.mkdirSync(workingPath);

			returnObj.createdDirectories.push(workingPath);

		}

		var destFileName = workingPath + destFilePathElementArray[len].replace(' ', '_').replace(/[\#\ \<\$\+\%\>\!\`\&\*\‘\|\{\?\“\=\}\/\:\\\@]/g, ''); //removes / character

		var fileData = fs.readFileSync(sourceFilePath);
		fs.writeFileSync(destFileName, fileData);

		return returnObj;
	}

	self.writeSureFile = function(destFilePath, fileData, options) {
		//copies the file after creating all the intermediate paths
		options = options ? options : {};
		var returnObj = {
			createdDirectories: []
		};
		
		var destFilePathElementArray = destFilePath.split('/'),
			workingPath = '';

		for (var i = 0, len = destFilePathElementArray.length - 1; i < len; i++) {
			var element = destFilePathElementArray[i]; //.replace(/[\#\ \<\$\+\%\>\!\`\&\*\‘\|\{\?\“\=\}\:\\\@]/g, ''); //allows / character 

			workingPath += element + '/';

			if (fs.existsSync(workingPath)) {
				continue;
			}

			fs.mkdirSync(workingPath);

			returnObj.createdDirectories.push(workingPath);

		}

		var destFileName = workingPath + destFilePathElementArray[len]; //.replace(' ', '_').replace(/[\#\ \<\$\+\%\>\!\`\&\*\‘\|\{\?\“\=\}\/\:\\\@]/g, ''); //removes / character


		if (options.append) {
			if (options.callback) {
				fs.appendFile(destFileName, fileData, options.callback);
			} else {
				fs.appendFileSync(destFileName, fileData);
			}
		} else {
			if (options.callback) {
				fs.writeFile(destFileName, fileData, options.callback);
			} else {
				fs.writeFileSync(destFileName, fileData);
			}
		}

		return returnObj;
	}
	
	qtools.deleteFile=function(filePath){
	var realPath='';
	try{
		realPath=self.realPath(filePath)
	}
	catch(e){return;}
		if (realPath){
		fs.unlinkSync(filePath);
		}
	}


	self.realPath = function(filePath) {
	  var result;
	  try {
		result = fs.realpathSync(filePath);
	  } catch (e) {
	  	//e.Error is "ENOENT, no such file or directory"
		result = '';
	  }
	  return result;
	}


	self.addMetaData = function(name, data) {
		var myId = this.employerFilename;
		if (typeof (self.metaData) == 'undefined') {
			self.metaData = {}
		}
		if (typeof (data) == 'object') {
			self.metaData[name] = qtools.clone(data);
		} else {
			self.metaData[name] = data;
		}
	}

	self.getMetaData = function() {
		if (typeof (self.metaData) == 'undefined') {
			self.metaData = {}
		}
		var outObj = {};
		outObj[self.employerFilename + "_" + self.uniqueId] = self.metaData;
		return outObj;
	}

	self.mergeMetaData = function(otherMetaData, forceIncludeMeIfEmpty) {
		if (forceIncludeMeIfEmpty == true) {
			return self.extend(otherMetaData, self.getMetaData())
		} else {

			if (typeof (self.metaData) == 'undefined') {
				return otherMetaData;
			} else {
				return self.extend(otherMetaData, self.getMetaData())
			}

		}
	}



	self.clone = function(inObj) {
		if (!newObj) {
			if (self.toType(inObj) == 'array') {
				var newObj = [];
			} else {
				var newObj = {};
			}
		}

		if (self.toType(inObj) != 'array') {

			for (var i in inObj) {
				if (inObj[i] !== null && typeof (inObj[i]) == "object") {
					newObj[i] = self.clone(inObj[i]);
				} else {
					newObj[i] = inObj[i];
				}
			}
		} else {
			for (var i = 0, len = inObj.length; i < len; i++) {
				if (self.toType (inObj[i]) == "object") {

					newObj[i] = self.clone(inObj[i]);
				} else {

					newObj[i] = inObj[i];
				}
			}

		}

		return newObj;
	}


	self.getSurePath = function(baseObj, subPathString, debug) {
		var target = baseObj,
			elements;
		self.getDottedPathLastProgressiveString = '';

		if (baseObj == null) {
			throw "qtools.getSurePath() says, baseObj cannot be null";
		}
		;

		if (subPathString.toString().match(/\.|\[/)) {
			var elements = subPathString.split(/\.|\[(.*?)]/);
		} else {
			var elements = [];
			elements.push(subPathString);
		}

		if (!subPathString) {
			return baseObj;
		}

		if (elements.length < 2) {
			return baseObj[subPathString];
		} else {
			for (var i = 0, len = elements.length; i < len; i++) {
				if (elements[i]) { //mainly eliminates trailing periods but would also eliminates double periods and other regex anomalies
					target = target[elements[i]];

					self.getDottedPathLastProgressiveString += elements[i] + '.';
					if (typeof (target) == 'undefined') {
						return;
					}
				}
			}
		}
		return target;
	}

	self.putSurePath = function(baseObj, subPathString, value, preserveExisting) {

		var elements, intermediate, propName;
		self.putDottedPathLastProgressiveString = '';

		preserveExisting = typeof (preserveExisting) != 'undefined' ? preserveExisting : false

		if (baseObj == null) {
			throw "qtools.getDottedPath() says, baseObj cannot be null";
		}
		;

		if (subPathString.toString().match(/\.|\[/)) {
			var elements = subPathString.split(/\.|(\[.*?)]/);
		} else {
			var elements = [];
			elements.push(subPathString);
		}

		if (!subPathString) {
			return baseObj;
		}

		if (elements.length < 2) {
			baseObj[subPathString] = value;
		} else {
			intermediate = baseObj;
			for (var i = 0, len = elements.length; i < len; i++) {
				if (elements[i]) { //mainly eliminates trailing periods but would also eliminates double periods and other regex anomalies
					propName = elements[i];

					if (elements[i + 1] && elements[i + 1].replace(/^\[/)) {
						elements[i + 1] = elements[i + 1].replace(/^\[/, '');
						var nextElement = [],
							nextElementType = 'array';
					} else {
						var nextElement = {},
							nextElementType = 'object';
					}

					if (propName) { //ignore trailing and redundant dots
						if (qtools.toType(intermediate[propName]) != nextElementType) {
							intermediate[propName] = nextElement;
						} else if (preserveExisting) {
							qtools.die(qtools.errorObject("'preserveExisting' flag is set, found non-object in path: " + propName + ' in ' + subPathString, baseObj));
						}

						intermediate = intermediate[propName];
					}
				}
			}

			intermediate = baseObj;
			for (var i = 0, len = elements.length; i < len - 1; i++) {
				if (elements[i]) { //mainly eliminates trailing periods but would also eliminate double periods
					propName = elements[i];
					intermediate = intermediate[propName];
				}
			}

			intermediate[elements[len - 1]] = value;

		}
		return baseObj;
	}

	self.extractDottedPaths = function(inObj) {
		var result,
			pathList = [];

		var extractDottedPathRecursionEngine = function(inObj, incomingPathString) {

			if (!incomingPathString) {
				incomingPathString = '';
			}

			if (self.toType(inObj) != 'array') {

				for (var i in inObj) {
					var suffix = '.' + i;
					if (inObj[i] !== null && typeof (inObj[i]) == "object") {
						extractDottedPathRecursionEngine(inObj[i], incomingPathString + suffix);
					} else {
						pathList.push((incomingPathString + suffix).replace(/\.$/, '').replace(/^\./, '')); //we accumulate leading and trailing dots, remove them

					}
				}

			} else {
				for (var i = 0, len = inObj.length; i < len; i++) {
					var suffix = '[' + i + ']';
					if (self.toType (inObj[i]) == "object") {
						extractDottedPathRecursionEngine(inObj[i], incomingPathString + suffix);
					} else {
						pathList.push((incomingPathString + suffix));
					}
				}

			}

			return pathList;
		}

		result = extractDottedPathRecursionEngine(inObj);

		return result;
	}
	
	self.toUpperCaseInitial=function(word){
		var initial=word[0].toUpperCase();
		word=word.replace(/^\w/, initial);
		return word;
	}
	
	self.toLowerCaseInitial=function(word){
		var initial=word[0].toLowerCase();
		word=word.replace(/^\w/, initial);
		return word;
	}

	self.snakeToCamel=function(inString, upperCaseInitial){
		var upperCaseInitial=(typeof(upperCaseInitial)=='undefined')?false:upperCaseInitial;
		var wordList=inString.split('_'),
			outString='';
		
		for (var i=0, len=wordList.length; i<len; i++){
			var element=self.toLowerCaseInitial(wordList[i]);
			if (i!==0 || upperCaseInitial){
				element=self.toUpperCaseInitial(element);
			}
			outString+=element;
		}
	return outString;


	},
	
	self.templateReplaceArray = function(args) {
	var outString = '';
	for (var i in args.replaceArray) {
		args.replaceObject = args.replaceArray[i];
		args.indexNumber = i;
		outString += self.templateReplace(args);
	}
	return outString;
},

self.templateReplace = function(args) {
	var template = args.template,
		replaceObject = args.replaceObject,
		leaveUnmatchedTagsIntact = args.leaveUnmatchedTagsIntact,
		transformations = args.transformations,

		outString = '',
		localReplaceObject = {};


	self.extend(this, {
		localReplaceObject: qtools.clone(replaceObject)
	}, args); //clones replaceObject
	self.localReplaceObject['leaveUnmatchedTagsIntact'] = leaveUnmatchedTagsIntact ? leaveUnmatchedTagsIntact : false;
	self.localReplaceObject['indexNumber'] = args.indexNumber ? args.indexNumber : 0;

	if (qtools.isNotEmpty(transformations)) {
		for (var fieldName in transformations) {
			self.localReplaceObject[fieldName] = transformations[fieldName](replaceObject);
		}
	}

	outString = template.replace(/<!([a-zA-Z0-9]+)!>/g, self.evaluatorFunction);

	//	outString='ttt'+outString+'qqq';
	return outString;
},

self.evaluatorFunction = function(matchedString, propertyName) {
	/*
	* This works as a callback from replace() in self.templateReplace. Looks up the
	* appropriate property in an object and returns it to replace a tag.
	*
	* Tags are the form <!replaceName!>.
	* */
	var outString = self.getSurePath(self.localReplaceObject, propertyName); //property names are allowed to be paths, eg, <!user.firstName!>


	if (typeof outString != 'undefined') {
		//console.log('propertyName='+propertyName+'==='+outString);
		return outString;
	} else {
		if (self.localReplaceObject['leaveUnmatchedTagsIntact']) {
			return '<!' + propertyName + '!>';
		} else {
			return '';
		}
	}
}





	//FINALIZE ====================================
	return this;


};

//END OF moduleFunction() ============================================================
util.inherits(moduleFunction, events.EventEmitter);
module.exports = moduleFunction;










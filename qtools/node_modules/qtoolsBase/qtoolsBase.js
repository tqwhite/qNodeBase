'use strict';

var events = require('events'),
	util = require('util'),
	fs = require('fs');

//START OF moduleFunction() ============================================================
var moduleFunction = function(self) {

	//INITIALIZATION ====================================
	events.EventEmitter.call(this);

	var self = self;
	var qtools = self;


	//LOCAL FUNCTIONS ====================================

	var delimitter = "========================================================",
		topDelim = "\n\n" + delimitter + "\n\n",
		bottomDelim = "\n\n" + delimitter + "\n\n";

	//BUILD OBJECT ====================================

	self.render = require('render');
	self.colors = require('colors'); //bold, italic, underline, inverse, yellow, cyan, white, magenta, green, red, grey, blue, rainbow, zebra, random

	self.delimitter = delimitter;
	self.topDelim = topDelim;
	self.bottomDelim = bottomDelim;

	self.wrapMessage = function(message) {
		return "\n\n" + delimitter + "\n\n" + message + "\n\n" + delimitter + "\n\n";
	}



	self.uniqueId = Math.floor(Math.random() * 100000);

	self.newGuid = function() {
		//thanks 'broofa': http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript
		return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
			var r = Math.random() * 16 | 0,
				v = c == 'x' ? r : (r & 0x3 | 0x8);
			return v.toString(16);
		}).toLowerCase();
	}

	self.dump = function(inData) {
		var render = self.render.ct(inData);
		//remove Array.replace() which shows up in listings
		render = render.replace(/,(\s+) function \(from, to\) \{\.\.\.\}/g, '$1');
		render = render.replace(/ function \(from, to\) \{\.\.\.\}/g, '');

		//it appears that render is inserting var0, and var1, throughout the display, confusing, remove them
		render = render.replace(/  var\d+,*\n/g, '');

		console.log("\n" + render);
	}


	self.forceEvent = function(eventName, outData) {
		self.emit(eventName, {
			eventName: eventName,
			data: outData
		});
	}

	self.removeNullElements = function(target, removeFalsy, keepFunction) {

		removeFalsy = !(typeof (removeFalsy) == 'undefined' || removeFalsy === '' || removeFalsy === false); //ie, any non-false value says removeFalsy values
		if (typeof (keepFunction) == 'undefined') {
			keepFunction = function(element, removeFalsy) {
				return (element || (removeFalsy && (typeof (element) == 'boolean' || typeof (element) == 'integer')));
			}
		}


		if (typeof (target) == 'object' && typeof (target.length) != 'undefined') {
			var outArray = [],
				inx = 0;
			for (var i = 0, len = target.length; i < len; i++) {
				var element = target[i];
				if (keepFunction(element, removeFalsy)) {
					outArray[inx] = element;
					inx++
				}
			}
			return outArray;
		} else if (typeof (target) == 'object') {
			var outObj = {};
			for (var i in target) {
				var element = target[i];
				if (keepFunction(element, removeFalsy)) {
					outObj[i] = element;
				}
			}

			return outObj;
		} else {
			throw "qtoolsBase.removeNulls() says, 'target must be object or array'";
		}
	}

	self.getByProperty = function(inArray, propertyName, propertyValue) {
		var len = inArray.length,
			inx = 0;
		for (inx = 0; inx < len; inx++) {
			if (inArray[inx][propertyName] == propertyValue) {
				return inArray[inx];
			}
		}
		return null;
	}

// 	self.clone = function(inData) {
// 		return JSON.parse(JSON.stringify(inData));
// 	}

	self.isEmpty = function(arg) {
		var objectEmptyFlag;

		if (typeof (arg) == 'function') {
			return false;
		}

		if (typeof (arg) == 'undefined') {
			return true;
		}

		if (typeof (arg) == 'object') {
			objectEmptyFlag = true; //assume it's empty until further notice
			for (var item in arg) {
				objectEmptyFlag = false; //found one
			}
		} else {
			objectEmptyFlag = false; //can't be full if it's not an object
		}

		return (objectEmptyFlag || arg == '' || arg.length == 0)
	}

	self.isNotEmpty = function(arg) {
		return !self.isEmpty(arg);
	}

	self.die = function(exceptionData) {
		switch (exceptionData) {
			case 'silent':
				process.exit(1);
				break;
			case 'trace':
				console.log("\n\n================================\n");
				console.trace();
				console.log("\n================================\n\n");
				process.exit(1);
				break;
			default:
				var prefix = this.employerFilename ? this.employerFilename : 'qtools.die()';
				var outObj = {};

				if (exceptionData) {
					prefix = prefix + " says";
					outObj[prefix] = exceptionData
					this.dump(outObj);
				} else {
					console.log(topDelim + 'Exiting ' + prefix + ' via qtools.die()' + bottomDelim);
				}
				process.exit(1);
				break;
		}
	}

	self.message = function(messageData, color, longFilename) {
		if (typeof (longFilename) == 'undefined') {
			longFilename = false;
		}
		var prefix = '\n**==*: ',
			suffix = longFilename ? ' (' + __dirname + '/' + this.employerFilename + ')\n' : ' (' + this.employerFilename + ')\n',
			message;
		if (typeof (messageData) == 'string') {
			message = prefix + messageData + suffix;
			if (color) {
				console.log(message[color].bold);
			} else {
				console.log(message.red.bold);
			}
			return;
		}
	}

	self.listProperties = function(inObject, toString) {
		if (typeof (toString) == 'undefined') {
			toString = false;
		}
		var outString = '';
		var list = [];
		var count = 0;
		var type = qtools.toType(inObject);

		if (type == 'object' || type == 'arguments') {

			for (var i in inObject) {
				var element = inObject[i];

				if (!toString) {
					console.log('item #' + count + ' named \'' + i + ' is ' + qtools.toType(element));
				} else {
					outString += 'item #' + count + ' named \'' + i + ' is ' + qtools.toType(element) + '\n';
				}
				count++;
			}
		} else if (type == 'array') {

			for (var i = 0, len = list.length; i < len; i++) {
				var element = inObject[i];

				if (!toString) {
					console.log('item #' + count + ' index \'' + i + ' is ' + qtools.toType(element));
				} else {
					outString += 'item #' + count + ' index \'' + i + ' is ' + qtools.toType(element) + '\n';
				}
				count++;
			}
		}

		return outString;
	}

	self.getSurePath = function(baseObj, subPathString, debug) {
		var target = baseObj,
			elements;
		self.getDottedPathLastProgressiveString = '';

		if (baseObj == null) {
			throw "qtools.getDottedPath() says, baseObj cannot be null";
		}
		;

		if (subPathString.toString().match(/\./)) {
			var elements = subPathString.split('.');
		} else {
			var elements = [];
			elements.push(subPathString);
		}

		if (!subPathString) {
			return baseObj;
		}

		if (elements.length < 2) {
			return baseObj[subPathString];
		} else {
			for (var i = 0, len = elements.length; i < len; i++) {
				if (elements[i]) { //mainly eliminates trailing periods but would also eliminate double periods
					target = target[elements[i]];

					self.getDottedPathLastProgressiveString += elements[i] + '.';
					if (typeof (target) == 'undefined') {
						return;
					}
				}
			}
		}
		return target;
	}

	self.putSurePath = function(baseObj, subPathString, value, preserveExisting) {

		var elements, intermediate, propName;
		self.putDottedPathLastProgressiveString = '';

		preserveExisting = typeof (preserveExisting) != 'undefined' ? preserveExisting : false

		if (baseObj == null) {
			throw "qtools.getDottedPath() says, baseObj cannot be null";
		}
		;

		if (subPathString.toString().match(/\./)) {
			var elements = subPathString.split('.');
		} else {
			var elements = [];
			elements.push(subPathString);
		}
		;
		if (!subPathString) {
			return baseObj;
		}

		if (elements.length < 2) {
			baseObj[subPathString] = value;
		} else {
			intermediate = baseObj;
			for (var i = 0, len = elements.length; i < len; i++) {
				if (elements[i]) { //mainly eliminates trailing periods but would also eliminate double periods
					propName = elements[i];

					if (propName) { //ignore trailing and redundant dots
						if (qtools.toType(intermediate[propName]) != 'object') {
							intermediate[propName] = {};
						} else if (preserveExisting) {
							qtools.die(qtools.errorObject("'preserveExisting' flag is set, found non-object in path: " + propName + ' in ' + subPathString, baseObj));
						}

						intermediate = intermediate[propName];
					}
				}
			}

			intermediate = baseObj;
			for (var i = 0, len = elements.length; i < len - 1; i++) {
				if (elements[i]) { //mainly eliminates trailing periods but would also eliminate double periods
					propName = elements[i];
					intermediate = intermediate[propName];
				}
			}

			intermediate[elements[len - 1]] = value;

		}
		return baseObj;
	}

	self.toType = function(obj) {
		if (obj === null) {
			return 'null';
		} else if (typeof (obj) == 'undefined') {
			return 'undefined';
		} else {
			return ({}).toString.call(obj).match(/\s([a-z|A-Z]+)/)[1].toLowerCase();
		}
	} //thanks: http://javascriptweblog.wordpress.com/2011/08/08/fixing-the-javascript-typeof-operator/

	self.errorObject = function(message, evidence) {
		var outObj = {};
		outObj.message = message;
		outObj.evidence = evidence;
		return outObj;
	}

	self.displayJson = function(inObject) {
		var jsonString = JSON.stringify(inObject);
		console.log(self.wrapMessage(jsonString));
	}

	self.validateProperties = function(args) {

		/*
				qtools.validateProperties({
					subject:args,
					targetScope: this, //will add listed items to targetScope
					propList:[
						{name:'parent', optional:true, requiredType:'', assertNotEmptyFlag:false}
					]
				});
				
		*/
		var name, type, notEmpty, element, importance, optional,
			outList = [],
			outMessage = '',
			inObj = args.subject,
			propList = args.propList,
			source = args.source ? args.source : self.employerFilename,
			importance = args.importance,
			optional = args.optional,
			targetScope = args.targetScope ? args.targetScope : '';


		if (self.toType(targetScope) != 'object') {
			targetScope = false;
		}

		source = source ? source + ' (via qtools.validateProperties) ' : 'qtools.validateProperties ';

		for (var i = 0, len = propList.length; i < len; i++) {
			var name = propList[i].name,
				importance = propList[i].importance,
				optional = propList[i].optional,
				requiredType = propList[i].requiredType ? propList[i].requiredType : false,
				assertNotEmptyFlag = propList[i].assertNotEmptyFlag,
				element = inObj[name];

			if ((!optional && importance != 'optional') && typeof (element) == 'undefined') {
				outList.push(name + ' is missing');
			}

			if (requiredType && self.toType(element) != requiredType) {
				outList.push(name + ' is not of type ' + requiredType);
			}
			if (assertNotEmptyFlag && self.isEmpty(element)) {
				outList.push(name + ' cannot be empty');
			}

			if (targetScope) {
				targetScope[name] = inObj[name];
			}
		}


		for (var i = 0, len = outList.length; i < len; i++) {
			outMessage += outList[i] + '\n';
		}

		if (outMessage) {
			console.log(self.wrapMessage(source + ' says, \n\n' + outMessage));
			self.die('silent');
		}

	}

	//jQUERY here. From https://github.com/jquery/jquery/blob/master/src/core.js#L390
	//call: self.extend(baseObject, extensionObject);
	self.extend = function() {
		var options, name, src, copy, copyIsArray, clone,
			target = arguments[0] || {},
			i = 1,
			length = arguments.length,
			deep = false;

		// Handle a deep copy situation
		if (typeof target === "boolean") {
			deep = target;

			// skip the boolean and the target
			target = arguments[i] || {};
			i++;
		}

		// Handle case when target is a string or something (possible in deep copy)
		if (typeof target !== "object" && !typeof (target) == 'function') {
			target = {};
		}

		// extend jQuery itself if only one argument is passed
		if (i === length) {
			target = self;
			i--;
		}

		for (; i < length; i++) {
			// Only deal with non-null/undefined values
			if ((options = arguments[i]) != null) {
				// Extend the base object
				for (name in options) {
					src = target[name];
					copy = options[name];

					// Prevent never-ending loop
					if (target === copy) {
						continue;
					}

					// Recurse if we're merging plain objects or arrays
					if (deep && copy && (typeof (copy) == 'object' || (copyIsArray = (typeof (copy.length) != 'undefined')))) {
						if (copyIsArray) {
							copyIsArray = false;
							clone = src && (typeof (src.length) != 'undefined') ? src : [];

						} else {
							clone = src && (typeof (src) == 'object') ? src : {};
						}

						// Never move original objects, clone them
						target[name] = self.extend(deep, clone, copy);

						// Don't bring in undefined values
					} else if (copy !== undefined) {
						target[name] = copy;
					}
				}
			}
		}

		// Return the modified object
		return target;
	};

	self.count = function(inData) {
		if (typeof (inData) == 'undefined') {
			return;
		}
		var type = self.toType(inData),
			outValue;
		switch (type) {
			case 'array':
				outValue = inData.length;
				break;
			case 'object':
				outValue = 0;
				for (var i in inData) {
					outValue++;
				}
				break;
			default:
				if (inData.hasOwnProperty('length') != 'undefined') {
					outValue = inData.length;
			}
		}

		return outValue;
	}

	self.getOnlyProperty = function(inObject) {
		var count = 0;
		for (var i in inObject) {
			var element = inObject[i];
			count++;
		}
		if (count != 1) {
			qtools.die(qtools.errorObject("qtools.getOnlyProperty() says, object must have exactly one property", inObject));
		}
		return element;
	}

	self.copySureFile = function(sourceFilePath, destFilePath) {
		//copies the file after creating all the intermediate paths

		var returnObj = {
			createdDirectories: []
		};

		if (!fs.existsSync(sourceFilePath)) {
			qtools.message('ERROR: *** file does NOT EXIST: ' + sourceFilePath + ' ***');
			return -1;
		}


		var destFilePathElementArray = destFilePath.split('/'),
			workingPath = '';

		for (var i = 0, len = destFilePathElementArray.length - 1; i < len; i++) {
			var element = destFilePathElementArray[i].replace(/[\#\ \<\$\+\%\>\!\`\&\*\‘\|\{\?\“\=\}\:\\\@]+/g, ''); //allows / character

			workingPath += element + '/';

			if (fs.existsSync(workingPath)) {
				continue;
			}

			fs.mkdirSync(workingPath);

			returnObj.createdDirectories.push(workingPath);

		}

		var destFileName = workingPath + destFilePathElementArray[len].replace(' ', '_').replace(/[\#\ \<\$\+\%\>\!\`\&\*\‘\|\{\?\“\=\}\/\:\\\@]/g, ''); //removes / character

		var fileData = fs.readFileSync(sourceFilePath);
		fs.writeFileSync(destFileName, fileData);

		return returnObj;
	}

	self.writeSureFile = function(fileData, destFilePath) {
		//copies the file after creating all the intermediate paths

		var returnObj = {
			createdDirectories: []
		};

		var destFilePathElementArray = destFilePath.split('/'),
			workingPath = '';

		for (var i = 0, len = destFilePathElementArray.length - 1; i < len; i++) {
			var element = destFilePathElementArray[i].replace(/[\#\ \<\$\+\%\>\!\`\&\*\‘\|\{\?\“\=\}\:\\\@]+/g, ''); //allows / character

			workingPath += element + '/';

			if (fs.existsSync(workingPath)) {
				continue;
			}

			fs.mkdirSync(workingPath);

			returnObj.createdDirectories.push(workingPath);

		}

		var destFileName = workingPath + destFilePathElementArray[len].replace(' ', '_').replace(/[\#\ \<\$\+\%\>\!\`\&\*\‘\|\{\?\“\=\}\/\:\\\@]/g, ''); //removes / character

		fs.writeFileSync(destFileName, fileData);

		return returnObj;
	}

	self.realPath = function(filePath) {
		return fs.realpathSync(filePath);
	}

	self.addMetaData = function(name, data) {
		var myId = this.employerFilename;
		if (typeof (self.metaData) == 'undefined') {
			self.metaData = {}
		}
		self.metaData[name] = qtools.clone(data);
	}

	self.getMetaData = function() {
		if (typeof (self.metaData) == 'undefined') {
			self.metaData = {}
		}
		var outObj = {};
		outObj[self.employerFilename + "_" + self.uniqueId] = self.metaData;
		return outObj;
	}

	self.mergeMetaData = function(otherMetaData, forceIncludeMeIfEmpty) {
		if (forceIncludeMeIfEmpty == true) {
			return self.extend(otherMetaData, self.getMetaData())
		} else {

			if (typeof (self.metaData) == 'undefined') {
				return otherMetaData;
			} else {
				return self.extend(otherMetaData, self.getMetaData())
			}

		}
	}



	self.clone = function(inObj) {
		if (!newObj) {
			if (self.toType(inObj) == 'array') {
				var newObj = [];
			} else {
				var newObj = {};
			}
		}

		if (self.toType(inObj) != 'array') {

			for (var i in inObj) {
				if (inObj[i] !== null && typeof (inObj[i]) == "object") {
					newObj[i] = self.clone(inObj[i]);
				} else {
					newObj[i] = inObj[i];
				}
			}
		} else {
			for (var i = 0, len = inObj.length; i < len; i++) {
				if (self.toType (inObj[i]) == "object") {

					newObj[i] = self.clone(inObj[i]);
				} else {

					newObj[i] = inObj[i];
				}
			}

		}

		return newObj;
	}

// 	var o = {
// 		foo: "bar",
// 		arr: [1, 2, 3],
// 		subo: {
// 			foo2: "bar2",
// 			xxx: {
// 				yyy: function() {
// 					console.log('hello')
// 				}
// 			}
// 		}
// 	};
// 
// 	var x = self.clone2(o);
// 
// 	console.dir(o);
// 	console.dir(x);
// 
// 	console.log('x.arr.length=' + x.arr.length + '\n');
// 	qtools.die(self.toType(x.arr))

	//FINALIZE ====================================
	return this;


};

//END OF moduleFunction() ============================================================
util.inherits(moduleFunction, events.EventEmitter);
module.exports = moduleFunction;



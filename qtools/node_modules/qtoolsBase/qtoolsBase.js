'use strict';

var util = require('util'),
	fs = require('fs');

//START OF moduleFunction() ============================================================
var moduleFunction = function(self) {

	//remember, this is instantiated by qtools.js

	//INITIALIZATION ====================================
	self.forceEvent = function(eventName, outData) {
		self.emit(eventName, {
			eventName: eventName,
			data: outData
		});
	}

	var self = self;
	var qtools = self;
	self.fs = fs;

	var delimitterHeavy = "========================================================",
		delimitterLight = "--------------------------------------------------------",
		topDelim = "\n\n" + delimitterLight + "\n\n",
		bottomDelim = "\n\n" + delimitterHeavy + "\n\n";


	//LOCAL FUNCTIONS ====================================


	//BUILD OBJECT ====================================

	self.colors = require('colors'); //bold, italic, underline, inverse, yellow, cyan, white, magenta, green, red, grey, blue, rainbow, zebra, random

	self.delimitter = delimitterHeavy; //sometimes it's convenient to be able to use this from outside
	self.topDelim = delimitterHeavy;
	self.bottomDelim = delimitterLight;

	self.wrapMessage = function(message) {
		return "\n\n" + delimitterLight + "\n\n" + message + "\n\n" + delimitterHeavy + "\n\n";
	}

	self.hash = function(inData) {
		if (!this.md5) {
			this.md5 = require('MD5');
		}

		var string = inData;

		if (inData == null) {
			string = 'null'
		} else if (typeof (inData) == 'object') {
			string = JSON.stringify(inData);
		}
		var hash = self.md5(string);

		return hash;
	}

	self.passwordHash = function(password, salt, args) {
		//from: http://stackoverflow.com/questions/19236327/nodejs-sha256-password-encryption
		if (typeof (self.crypto) == 'undefined') {
			self.crypto = require('crypto');
		}


		args = args || {};
		var algorithmName = args.algorithmName || 'sha256',
			outputFormat = args.outputFormat || 'hex';

		var hash = self.crypto.createHash(algorithmName).update(password).digest(outputFormat);
		return hash;
	}

	self.uniqueId = Math.floor(Math.random() * 100000);

	var calcHash = function(args) {
		if (typeof (self.crypto) == 'undefined') {
			self.crypto = require('crypto');
		}
		var inString = args.inString || self.crypto.randomBytes(40).toString('hex');
		var salt = args.salt || 'returns same thing if inString is specified';
		if (typeof (self.crypto) == 'undefined') {
			self.crypto = require('crypto');
		}
		return self.crypto.pbkdf2Sync(inString.toString(), salt.toString(), args.iterations, args.keyLength).toString('hex');
	}



	self.newId = function(args) {
		var sampleArg = {
			inString: 'password',
			resultLength: 6, //
			allowRepeat: false
		}
		var sampleArg = {
			resultLength: 6, //defaults to 6,
			allowRepeat: false, //defaults to false
			uniqueSpaceId: 'categoryName',
			inString: 'password', //optional, returns random string of keyLength
			salt: 'x', //optional, defaults to some constant string
			iterations: 10, //optional, defaults to 10
		}

		args = qtools.clone(args); //don't want to risk writing back to caller

		if (typeof (self.invocationCount) == 'undefined') {
			self.invocationCount = 0;
		}
		self.invocationCount++;
		args = args || {};
		args.iterations = 10;
		args.keyLength = Math.max(Math.ceil(args.resultLength / 2), 1) || 3; //returns hex, two chars per result byte

		var idListName = args.uniqueSpaceId ? args.uniqueSpaceId : 'idList';

		if (typeof (self[idListName]) == 'undefined') {
			self[idListName] = [];
		}

		var keySpace = Math.pow(16, args.keyLength * 2);


		var a = calcHash(args);
		if (args.allowRepeat || self[idListName].indexOf(a) < 0) {
			self[idListName].push(a);
			return a;
		} else {
			if (self[idListName].length == keySpace) {

			} else {

				for (var i = 0, len = keySpace; i < len; i++) {
					args.inString += '-' + i;
					a = calcHash(args);

					if (self[idListName].indexOf(a) < 0) {
						self[idListName].push(a);
						return a;
					}

					continue;
				}

			}
		}



		//		var outMessage="qtools.newId used up all " + keySpace + " combinations of " + args.keyLength*2 + " length hexadecimal keys";
		//		throw outMessage;
		return '';

	}


	self.newGuid = function() {
		//thanks 'broofa': http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript
		return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
			var r = Math.random() * 16 | 0,
				v = c == 'x' ? r : (r & 0x3 | 0x8);
			return v.toString(16);
		}).toLowerCase();
	}

	self.dump = function(inData, returnStringFlag) {
		returnStringFlag = returnStringFlag ? returnStringFlag : false;

		if (returnStringFlag) {
			return util.inspect(inData, {
				depth: null
			});
		} else {
			console.log('\n' + util.inspect(inData, {
						depth: null
					}) + '\n');
		}
	}

	self.dumpToFile = function(inData, filePath, fileOptions) {

		var outString = self.dump(inData, true);
		if (fileOptions.addSeparator) {
			outString = self.wrapMessage(outString);
		}

		self.writeSureFile(filePath, outString, fileOptions);
	}


	self.addSpaces = function(inString, desiredLength, fillChar) {
		fillChar = fillChar ? fillChar : ' ';
		var len = inString.length,
			remainder = Math.ceil((desiredLength - len) / fillChar.length),
			outString = inString;

		for (var i = 0; i < remainder; i++) {
			outString += fillChar;
		}
		return outString;

	}

	self.dumpFlat = function(inData, returnStringFlag, filterList) {
		if (typeof (returnStringFlag) != 'string') {
			returnStringFlag = returnStringFlag ? returnStringFlag : false;
		}

		var dottedPathList = qtools.extractDottedPaths(inData),
			outString = '';

		if (typeof (returnStringFlag) == 'string') {
			console.log('\n\nSTART ' + returnStringFlag + ' ' + delimitterHeavy);
		}

		var maxNameLength = 0;
		for (var i = 0, len = dottedPathList.length; i < len; i++) {
			var element = dottedPathList[i],
				len2 = element.length,
				maxNameLength = (len2 > maxNameLength) ? len2 : maxNameLength;
			if (len2 > maxNameLength) {
				var last = element;
			}
		}
		maxNameLength = maxNameLength + 5;

		for (var i = 0, len = dottedPathList.length; i < len; i++) {
			var element = dottedPathList[i],
				violatesFilter = false;

			if (filterList) {
				violatesFilter = true
				for (var j = 0, len2 = filterList.length; j < len2; j++) {
					if (element.match(new RegExp(filterList[j]))) {
						violatesFilter = false;
						break;
					}
				}
			}

			if (violatesFilter) {
				continue;
			}

			var value = qtools.getSurePath(inData, element);

			outString += self.addSpaces(element, maxNameLength, '.') + ' ' + value;

			if (!returnStringFlag || typeof (returnStringFlag) == 'string') {
				console.log(outString);
				outString = '';
			}



		}


		if (typeof (returnStringFlag) == 'string') {

			if (typeof (returnStringFlag) == 'string') {
				console.log('END ' + returnStringFlag + ' ' + delimitterLight + '\n\n');
			}
		} else if (returnStringFlag) {
			return outString;
		}
	}


	self.removeNullElements = function(target, removeFalsy, keepFunction) {

		removeFalsy = !(typeof (removeFalsy) == 'undefined' || removeFalsy === '' || removeFalsy === false); //ie, any non-false value says removeFalsy values
		if (typeof (keepFunction) == 'undefined') {
			keepFunction = function(element, removeFalsy) {
				return (element || (removeFalsy && (typeof (element) == 'boolean' || typeof (element) == 'integer')));
			}
		}


		if (typeof (target) == 'object' && typeof (target.length) != 'undefined') {
			var outArray = [],
				inx = 0;
			for (var i = 0, len = target.length; i < len; i++) {
				var element = target[i];
				if (keepFunction(element, removeFalsy)) {
					outArray[inx] = element;
					inx++
				}
			}
			return outArray;
		} else if (typeof (target) == 'object') {
			var outObj = {};
			for (var i in target) {
				var element = target[i];
				if (keepFunction(element, removeFalsy)) {
					outObj[i] = element;
				}
			}

			return outObj;
		} else {
			throw "qtoolsBase.removeNulls() says, 'target must be object or array'";
		}
	}

	self.removeFromArray = function(inArray, from, to) {
		/*
			Array Remove - By John Resig (MIT Licensed)
			http://ejohn.org/blog/javascript-array-remove/
			Remove the second item from the array
				array.remove(1);
			Remove the second-to-last item from the array
				array.remove(-2);
			Remove the second and third items from the array
				array.remove(1,2);
			Remove the last and second-to-last items from the array
				array.remove(-2,-1);
		*/
		var rest = inArray.slice((to || from) + 1 || inArray.length);
		inArray.length = from < 0 ? inArray.length + from : from;
		return inArray.push.apply(inArray, rest);

	}
	self.getByProperty = function(inData, propertyName, propertyValue) {
		if (inData.length) {
			var len = inData.length,
				inx = 0;
			for (inx = 0; inx < len; inx++) {
				if (self.getSurePath(inData[inx], propertyName) == propertyValue) {
					return inData[inx];
				}
			}
		} else if (typeof (inData) == 'object') {

			for (var inx in inData) {

				if (self.getSurePath(inData[inx], propertyName) == propertyValue) {
					return inData[inx];
				}
			}
		}
		return null;
	}


	self.getIndexByValueDISCARD = function(inObject, propertyValue, dottedSubPath) {
		//qtools.getIndexByValue(self.dataSource.tmp, "z", 'inner.val');
		for (var i in inObject) {
			var element = inObject[i];
			if (typeof (dottedSubPath) != 'undefined') {
				element = qtools.getSurePath(element, dottedSubPath);
			}

			if (element === propertyValue) {
				return i;
			}
		}

	}

	self.getIndexByValue = function(inObject, propertyValue, dottedSubPath) {
		propertyValue = propertyValue.trim();
		if (qtools.toType(inObject) == 'object') {
			//qtools.getIndexByValue(self.dataSource.tmp, "z", 'inner.val');
			for (var i in inObject) {
				var element = inObject[i];
				if (typeof (dottedSubPath) != 'undefined') {
					element = qtools.getSurePath(element, dottedSubPath);
				}

				if (element === propertyValue) {
					return i;
				}
			}

		} else if (qtools.toType(inObject) == 'array') {

			for (var i = 0, len = inObject.length; i < len; i++) {
				var element = inObject[i];
				if (element == propertyValue) {
					return i;
				}
			}

		} else {
			return '';
		}
	}


	// 	self.clone = function(inData) {
	// 		return JSON.parse(JSON.stringify(inData));
	// 	}

	self.isEmpty = function(arg) {
		var objectEmptyFlag;

		if (typeof (arg) == 'function') {
			return false;
		}

		if (typeof (arg) == 'undefined') {
			return true;
		}

		if (typeof (arg) == 'object') {
			objectEmptyFlag = true; //assume it's empty until further notice
			for (var item in arg) {
				objectEmptyFlag = false; //found one
			}
		} else {
			objectEmptyFlag = false; //can't be full if it's not an object
		}

		return (objectEmptyFlag || arg == '' || arg.length == 0)
	}

	self.isNotEmpty = function(arg) {
		return !self.isEmpty(arg);
	}

	self.die = function(exceptionData) {
		switch (exceptionData) {
			case 'defer':
				setTimeout(function() {
					self.die('died after delay');
				}, 10000)
				break;
			case 'silent':
				process.exit(1);
				break;
			case 'trace': //stack
				console.log("\n\n================================\n");
				console.trace();
				console.log("\n================================\n\n");
				process.exit(1);
				break;
			default:
				var prefix = this.employerFilename ? this.employerFilename : 'qtools.die()';
				var outObj = {};

				if (exceptionData) {
					prefix = prefix + " says";
					outObj[prefix] = exceptionData
					this.dump(outObj);
				} else {
					console.log(topDelim + 'Exiting ' + prefix + ' via qtools.die()' + bottomDelim);
				}
				process.exit(1);
				break;
		}
	}

	self.errorExit = function(exceptionData) {
		var outMessage;
		if (typeof (exceptionData) != 'string') {
			outMessage = self.dump(exceptionData, true);
		} else {
			outMessage = exceptionData;
		}

		process.stderr.write(outMessage);
		process.exit(1);
	}

	self.successExit = function(exceptionData) {
		if (exceptionData) {
			var outMessage = '';
			if (typeof (exceptionData) != 'string') {
				outMessage = self.dump(exceptionData, true);
			}
			process.stderr.write(outMessage);
		}
		process.exit(0);
	}


	self.message = function(messageData, color, longFilename) {
		if (typeof (console) == 'undefined') {
			return;
		}
		if (typeof (longFilename) == 'undefined') {
			longFilename = false;
		}
		var prefix = '\n**==*: ',
			showEmployer = this.employerFilename ? '(' + this.employerFilename + ')' : '',
			suffix = longFilename ? ' (' + __dirname + '/' + this.employerFilename + ')\n' : showEmployer + '\n',
			message;
		if (typeof (messageData) == 'string') {
			message = prefix + messageData + suffix;
			if (color) {
				console.log(message[color].bold);
			} else {
				console.log(message.red.bold);
			}
			return;
		}
	}


	self.byObjectProperty = function(fieldName, transformer) {
		//called: resultArray=someArray.sort(qtools.byObjectProperty('somePropertyName'));
		//based on closure of fieldName
		var fullNameSort;
		return fullNameSort = function(a, b) {
			var localFieldName = fieldName, //for debug
				localTransformer = transformer; //for debug

			if (typeof (fieldName) == 'function') {
				var aa = a,
					bb = b;
				var transformer = fieldName;
			} else {
				var aa = qtools.getSurePath(a, fieldName),
					bb = qtools.getSurePath(b, fieldName);
			}

			if (typeof (transformer) == 'function') {
				aa = transformer(aa);
				bb = transformer(bb);
			} else if (transformer) {
				switch (transformer) {
					case 'caseInsensitive':
						aa = aa.toLowerCase();
						bb = bb.toLowerCase();
						break;
					default:
						qtools.consoleMessage('qtools.byObjectProperty says, No such transformer as: ' + transformer);
						break;
				}
			}

			if (!bb && !aa) {
				return 0;
			}
			if (!bb) {
				return -1;
			}
			if (!aa) {
				return 1;
			}

			if (aa > bb) {
				return 1;
			}
			if (aa < bb) {
				return -1;
			}
			return 0;
		}
	},

	self.listProperties = function(inObject, toString, args) {
		args = args ? args : {};
		var maxShowStringLength = args.maxShowStringLength ? maxShowStringLength : 100;

		if (typeof (toString) == 'undefined') {
			toString = false;
		}
		var outString = '';
		var list = [];
		var count = 0;
		var type = qtools.toType(inObject);

		if (type == 'object' || type == 'arguments') {
			var outList = [];
			for (var i in inObject) {
				var element = inObject[i],
					showElement;

				if (['object', 'array', 'function'].indexOf(qtools.toType(element)) == -1) {
					if (element == null) {
						showElement = 'null'.green;
					} else {
						if (element.length > maxShowStringLength) {
							element = element.substr(0, maxShowStringLength) + ' ... (length=' + element.length + ')';
						}
						if (toString) {
							showElement = element.toString();
						} else {
							showElement = element.toString().green;
						}
					}
					if (toString) {
						var tmp = ('item #' + count + ' named \'') + i + '\' is a ' + qtools.toType(element) + ' value= ' + showElement;
					} else {
						var tmp = ('item #' + count + ' named \'').grey + i.red + '\' is a '.grey + qtools.toType(element).red + ' value= '.grey + showElement;
					}
					outList.push({
						name: i,
						string: tmp
					});
				} else {
					if (toString) {
						var tmp = ('item #' + count + ' named \'') + i + '\' is a ' + qtools.toType(element);
					} else {
						var tmp = ('item #' + count + ' named \'').grey + i.red + '\' is a '.grey + qtools.toType(element).red;
					}
					outList.push({
						name: i,
						string: tmp
					});
				}
				count++;
			}

			outList = outList.sort(qtools.byObjectProperty('name'));

			for (var i = 0, len = outList.length; i < len; i++) {
				var element = outList[i];

				if (!toString) {
					console.log(element.string);
				} else {
					outString += element.string + ';     ';
				}
			}

		} else if (type == 'array') {

			for (var i = 0, len = list.length; i < len; i++) {
				var element = inObject[i];

				if (!toString) {
					console.log('item #' + count + ' index \'' + i + ' is ' + qtools.toType(element));
				} else {
					outString += 'item #' + count + ' index \'' + i + ' is ' + qtools.toType(element) + '\n';
				}
				count++;
			}
		}

		return outString;
	}

	self.toType = function(obj) {
		if (obj === null) {
			return 'null';
		} else if (typeof (obj) == 'undefined') {
			return 'undefined';
		} else {
			return ({}).toString.call(obj).match(/\s([a-z|A-Z]+)/)[1].toLowerCase();
		}
	} //thanks: http://javascriptweblog.wordpress.com/2011/08/08/fixing-the-javascript-typeof-operator/

	self.errorObject = function(message, evidence) {
		var outObj = {};
		outObj.message = message;
		outObj.evidence = evidence;
		return outObj;
	}

	self.displayJson = function(inObject) {
		var jsonString = JSON.stringify(inObject);
		console.log(self.wrapMessage(jsonString));
	}

	self.validateProperties = function(args, doNotDie) {

		/*
				qtools.validateProperties({
					subject:args,
					targetScope: this, //will add listed items to targetScope
					propList:[
						{name:'parent', optional:true, requiredType:'', assertNotEmptyFlag:false}
					]
				});
				
		*/
		var name, type, notEmpty, element, importance, optional,
			outList = [],
			outMessage = '',
			inObj = args.subject,
			propList = args.propList,
			source = args.source ? args.source : self.employerFilename,
			importance = args.importance,
			optional = args.optional,
			targetScope = args.targetScope ? args.targetScope : '',
			result = '';

		doNotDie = doNotDie ? true : false;

		if (self.toType(targetScope) != 'object') {
			targetScope = false;
		}

		source = source ? source + ' (via qtools.validateProperties) ' : 'qtools.validateProperties ';

		for (var i = 0, len = propList.length; i < len; i++) {
			var name = propList[i].name,
				importance = propList[i].importance,
				optional = propList[i].optional,
				requiredType = propList[i].requiredType ? propList[i].requiredType : false,
				assertNotEmptyFlag = propList[i].assertNotEmptyFlag,
				element = inObj[name];

			if ((!optional && importance != 'optional') && typeof (element) == 'undefined') {
				outList.push(name + ' is missing');
			}

			if (requiredType && self.toType(element) != requiredType) {
				outList.push(name + ' is not of type ' + requiredType);
			}
			if (assertNotEmptyFlag && self.isEmpty(element)) {
				outList.push(name + ' cannot be empty');
			}

			if (targetScope) {
				targetScope[name] = inObj[name];
			}
		}


		for (var i = 0, len = outList.length; i < len; i++) {
			outMessage += outList[i] + '\n';
		}

		if (outMessage) {
			console.log(self.wrapMessage(source + ' says, \n\n' + outMessage));
			if (!doNotDie) {
				self.die('silent');
			}

			result = source + ' says, ' + outMessage;
		}
		return result;
	}

	//jQUERY here. From https://github.com/jquery/jquery/blob/master/src/core.js#L390
	//call: self.extend(baseObject, extensionObject);
	self.extend = function() {
		var options, name, src, copy, copyIsArray, clone,
			target = arguments[0] || {},
			i = 1,
			length = arguments.length,
			deep = false;

		// Handle a deep copy situation
		if (typeof target === "boolean") {
			deep = target;

			// skip the boolean and the target
			target = arguments[i] || {};
			i++;
		}

		// Handle case when target is a string or something (possible in deep copy)
		if (typeof target !== "object" && !typeof (target) == 'function') {
			target = {};
		}

		// extend jQuery itself if only one argument is passed
		if (i === length) {
			target = self;
			i--;
		}

		for (; i < length; i++) {
			// Only deal with non-null/undefined values
			if ((options = arguments[i]) != null) {
				// Extend the base object
				for (name in options) {
					src = target[name];
					copy = options[name];

					// Prevent never-ending loop
					if (target === copy) {
						continue;
					}

					// Recurse if we're merging plain objects or arrays
					if (deep && copy && (typeof (copy) == 'object' || (copyIsArray = (typeof (copy.length) != 'undefined')))) {
						if (copyIsArray) {
							copyIsArray = false;
							clone = src && (typeof (src.length) != 'undefined') ? src : [];

						} else {
							clone = src && (typeof (src) == 'object') ? src : {};
						}

						// Never move original objects, clone them
						target[name] = self.extend(deep, clone, copy);

						// Don't bring in undefined values
					} else if (copy !== undefined) {
						target[name] = copy;
					}
				}
			}
		}

		// Return the modified object
		return target;
	};

	self.count = function(inData) {
		if (typeof (inData) == 'undefined') {
			return;
		}
		var type = self.toType(inData),
			outValue;
		switch (type) {
			case 'array':
				outValue = inData.length;
				break;
			case 'object':
				outValue = 0;
				for (var i in inData) {
					outValue++;
				}
				break;
			default:
				if (inData.hasOwnProperty('length') != 'undefined') {
					outValue = inData.length;
			}
		}

		return outValue;
	}

	self.getOnlyProperty = function(inObject) {
		var count = 0;
		for (var i in inObject) {
			var element = inObject[i];
			count++;
		}
		if (count != 1) {
			qtools.die(qtools.errorObject("qtools.getOnlyProperty() says, object must have exactly one property", inObject));
		}
		return element;
	}

	self.copySureFile = function(destFilePath, sourceFilePath) {
		//copies the file after creating all the intermediate paths

		var returnObj = {
			createdDirectories: []
		};

		if (!fs.existsSync(sourceFilePath)) {
			qtools.message('ERROR: *** file does NOT EXIST: ' + sourceFilePath + ' ***');
			return -1;
		}


		var destFilePathElementArray = destFilePath.split('/'),
			workingPath = '';

		for (var i = 0, len = destFilePathElementArray.length - 1; i < len; i++) {
			var element = destFilePathElementArray[i].replace(/[\#\ \<\$\+\%\>\!\`\&\*\‘\|\{\?\“\=\}\:\\\@]+/g, ''); //allows / character

			workingPath += element + '/';

			if (fs.existsSync(workingPath)) {
				continue;
			}

			fs.mkdirSync(workingPath);

			returnObj.createdDirectories.push(workingPath);

		}

		var destFileName = workingPath + destFilePathElementArray[len].replace(' ', '_').replace(/[\#\ \<\$\+\%\>\!\`\&\*\‘\|\{\?\“\=\}\/\:\\\@]/g, ''); //removes / character

		var fileData = fs.readFileSync(sourceFilePath);
		fs.writeFileSync(destFileName, fileData);

		return returnObj;
	}

	self.writeSureFile = function(destFilePath, fileData, options) {
		//copies the file after creating all the intermediate paths
		options = options ? options : {};
		var returnObj = {
			createdDirectories: []
		};

		var destFilePathElementArray = destFilePath.split('/'),
			workingPath = '';

		for (var i = 0, len = destFilePathElementArray.length - 1; i < len; i++) {
			var element = destFilePathElementArray[i]; //.replace(/[\#\ \<\$\+\%\>\!\`\&\*\‘\|\{\?\“\=\}\:\\\@]/g, ''); //allows / character 

			workingPath += element + '/';

			if (fs.existsSync(workingPath)) {
				continue;
			}

			fs.mkdirSync(workingPath);

			returnObj.createdDirectories.push(workingPath);

		}

		var destFileName = workingPath + destFilePathElementArray[len]; //.replace(' ', '_').replace(/[\#\ \<\$\+\%\>\!\`\&\*\‘\|\{\?\“\=\}\/\:\\\@]/g, ''); //removes / character


		if (options.append) {
			if (options.callback) {
				fs.appendFile(destFileName, fileData, options.callback);
			} else {
				fs.appendFileSync(destFileName, fileData);
			}
		} else {
			if (options.callback) {
				fs.writeFile(destFileName, fileData, options.callback);
			} else {
				fs.writeFileSync(destFileName, fileData);
			}
		}

		return returnObj;
	}

	qtools.deleteFile = function(filePath) {
		var realPath = '';
		try {
			realPath = self.realPath(filePath)
		} catch (e) {
			return;
		}
		if (realPath) {
			fs.unlinkSync(filePath);
		}
	}


	self.realPath = function(filePath) {
		var result;
		try {
			result = fs.realpathSync(filePath);
		} catch (e) {
			//e.Error is "ENOENT, no such file or directory"
			result = '';
		}
		return result;
	}


	self.addMetaData = function(name, data) {
		var myId = this.employerFilename;
		if (typeof (self.metaData) == 'undefined') {
			self.metaData = {}
		}
		if (typeof (data) == 'object') {
			self.metaData[name] = qtools.clone(data);
		} else {
			self.metaData[name] = data;
		}
	}

	self.getMetaData = function() {
		if (typeof (self.metaData) == 'undefined') {
			self.metaData = {}
		}
		var outObj = {};
		outObj[self.employerFilename + "_" + self.uniqueId] = self.metaData;
		return outObj;
	}

	self.mergeMetaData = function(otherMetaData, forceIncludeMeIfEmpty) {
		if (forceIncludeMeIfEmpty == true) {
			return self.extend(otherMetaData, self.getMetaData())
		} else {

			if (typeof (self.metaData) == 'undefined') {
				return otherMetaData;
			} else {
				return self.extend(otherMetaData, self.getMetaData())
			}

		}
	}



	self.clone = function(inObj) {
		if (!newObj) {
			if (self.toType(inObj) == 'array') {
				var newObj = [];
			} else {
				var newObj = {};
			}
		}

		if (self.toType(inObj) != 'array') {

			for (var i in inObj) {
				if (inObj[i] !== null && typeof (inObj[i]) == "object") {
					switch (inObj[i].constructor) {
						case Date:
							newObj[i] = new Date(inObj[i].toString());
							break;
						default:
							newObj[i] = self.clone(inObj[i]);
							break;
					}
				} else {
					newObj[i] = inObj[i];
				}
			}
		} else {
			for (var i = 0, len = inObj.length; i < len; i++) {
				if (self.toType (inObj[i]) == "object") {

					newObj[i] = self.clone(inObj[i]);
				} else {

					newObj[i] = inObj[i];
				}
			}

		}

		return newObj;
	}


	self.getSurePath = function(baseObj, subPathString, defaultReturn, debug) {
		var target = baseObj,
			elements;
		self.getDottedPathLastProgressiveString = '';

		if (baseObj == null) {
			throw "qtools.getSurePath() says, baseObj cannot be null";
		}
		;

		if (subPathString.toString().match(/\.|\[/)) {
			var elements = subPathString.split(/\.|\[(.*?)]/);
		} else {
			var elements = [];
			elements.push(subPathString);
		}

		if (!subPathString) {
			return baseObj;
		}

		if (elements.length < 2) {
			return baseObj[subPathString];
		} else {
			for (var i = 0, len = elements.length; i < len; i++) {
				if (elements[i]) { //mainly eliminates trailing periods but would also eliminates double periods and other regex anomalies
					target = target[elements[i]];

					self.getDottedPathLastProgressiveString += elements[i] + '.';
					if (typeof (target) == 'undefined') {

						if (typeof (defaultReturn) != 'undefined' && typeof (target) == 'undefined') {
							return defaultReturn;
						}

						return;
					}
				}
			}
		}

		return target;
	}

	self.putSurePath = function(baseObj, subPathString, value, preserveExisting) {

		var elements, intermediate, propName;
		self.putDottedPathLastProgressiveString = '';

		preserveExisting = typeof (preserveExisting) != 'undefined' ? preserveExisting : false

		if (baseObj == null) {
			throw "qtools.getDottedPath() says, baseObj cannot be nullx " + subPathString;
		}
		;

		if (subPathString.toString().match(/\.|\[/)) {
			var elements = subPathString.split(/\.|(\[.*?)]/);
		} else {
			var elements = [];
			elements.push(subPathString);
		}

		if (!subPathString) {
			return baseObj;
		}

		if (elements.length < 2) {
			baseObj[subPathString] = value;
		} else {
			intermediate = baseObj;
			for (var i = 0, len = elements.length; i < len; i++) {
				if (elements[i]) { //mainly eliminates trailing periods but would also eliminates double periods and other regex anomalies
					propName = elements[i];

					if (elements[i + 1] && elements[i + 1].replace(/^\[/)) {
						elements[i + 1] = elements[i + 1].replace(/^\[/, '');
						var nextElement = [],
							nextElementType = 'array';
					} else {
						var nextElement = {},
							nextElementType = 'object';
					}

					if (propName) { //ignore trailing and redundant dots
						if (qtools.toType(intermediate[propName]) != nextElementType) {
							intermediate[propName] = nextElement;
						} else if (preserveExisting) {
							qtools.die(qtools.errorObject("'preserveExisting' flag is set, found non-object in path: " + propName + ' in ' + subPathString, baseObj));
						}

						intermediate = intermediate[propName];
					}
				}
			}

			intermediate = baseObj;
			for (var i = 0, len = elements.length; i < len - 1; i++) {
				if (elements[i]) { //mainly eliminates trailing periods but would also eliminate double periods
					propName = elements[i];
					intermediate = intermediate[propName];
				}
			}

			intermediate[elements[len - 1]] = value;

		}
		return baseObj;
	}

	self.deleteFile = function(filePath) {
		if (fs.existsSync(filePath)) {
			fs.unlinkSync(filePath);
		}
	}

	self.extractDottedPaths = function(inObj) {
		var result,
			pathList = [];

		var extractDottedPathRecursionEngine = function(inObj, incomingPathString) {

			if (!incomingPathString) {
				incomingPathString = '';
			}

			if (self.toType(inObj) != 'array') {

				for (var i in inObj) {
					var suffix = '.' + i;
					if (inObj[i] !== null && typeof (inObj[i]) == "object") {
						extractDottedPathRecursionEngine(inObj[i], incomingPathString + suffix);
					} else {
						pathList.push((incomingPathString + suffix).replace(/\.$/, '').replace(/^\./, '')); //we accumulate leading and trailing dots, remove them

					}
				}

			} else {
				for (var i = 0, len = inObj.length; i < len; i++) {
					var suffix = '[' + i + ']';
					if (self.toType (inObj[i]) == "object") {
						extractDottedPathRecursionEngine(inObj[i], incomingPathString + suffix);
					} else {
						pathList.push((incomingPathString + suffix));
					}
				}

			}

			return pathList;
		}

		result = extractDottedPathRecursionEngine(inObj);

		return result;
	}

	self.toUpperCaseInitial = function(word) {
		var initial = word[0].toUpperCase();
		word = word.replace(/^\w/, initial);
		return word;
	}

	self.toLowerCaseInitial = function(word) {
		var initial = word[0].toLowerCase();
		word = word.replace(/^\w/, initial);
		return word;
	}

	self.snakeToCamel = function(inString, upperCaseInitial) {
		var upperCaseInitial = (typeof (upperCaseInitial) == 'undefined') ? false : upperCaseInitial;
		var wordList = inString.split('_'),
			outString = '';

		for (var i = 0, len = wordList.length; i < len; i++) {
			var element = self.toLowerCaseInitial(wordList[i]);
			if (i !== 0 || upperCaseInitial) {
				element = self.toUpperCaseInitial(element);
			}
			outString += element;
		}
		return outString;


	},

	self.templateReplaceArray = function(args) {
		var outString = '';
		for (var i in args.replaceArray) {
			args.replaceObject = args.replaceArray[i];
			if (qtools.toType(args.replaceObject) != 'object') {
				continue;
			}
			args.indexNumber = i;
			outString += self.templateReplace(args);
		}


		return outString;
	},

	self.templateReplace = function(args) {

		// {
		// 	template:template,
		// 	replaceObject:replaceObject,
		// 	leaveUnmatchedTagsIntact:true,
		// 	transformations:{showItemNo:function(replaceObject){ return "Item Number: "+replaceObject.indexNumber; }}
		// }

		var template = args.template,
			replaceObject = args.replaceObject,
			leaveUnmatchedTagsIntact = args.leaveUnmatchedTagsIntact,
			transformations = args.transformations,

			outString = '',
			localReplaceObject = {};


		self.extend(this, {
			localReplaceObject: qtools.clone(replaceObject)
		}, args); //clones replaceObject

		self.localReplaceObject['leaveUnmatchedTagsIntact'] = leaveUnmatchedTagsIntact ? leaveUnmatchedTagsIntact : false;
		self.localReplaceObject['indexNumber'] = args.indexNumber ? args.indexNumber : 0;

		if (qtools.isNotEmpty(transformations)) {
			for (var fieldName in transformations) {
				self.localReplaceObject[fieldName] = transformations[fieldName](self.localReplaceObject);
			}
		}

		outString = template.replace(/<!([a-zA-Z0-9\/_]+)!>/g, self.evaluatorFunction);
		outString = outString.replace(/<!([a-zA-Z0-9\/_]+)!>/g, self.evaluatorFunction);

		//	outString='ttt'+outString+'qqq';
		return outString;
	},

	self.evaluatorFunction = function(matchedString, propertyName) {
		/*
		* This works as a callback from replace() in self.templateReplace. Looks up the
		* appropriate property in an object and returns it to replace a tag.
		*
		* Tags are the form <!replaceName!>.
		* */
		var outString = self.getSurePath(self.localReplaceObject, propertyName); //property names are allowed to be paths, eg, <!user.firstName!>


		if (typeof outString != 'undefined') {
			//console.log('propertyName='+propertyName+'==='+outString);
			return outString;
		} else {
			if (self.localReplaceObject['leaveUnmatchedTagsIntact']) {
				return '<!' + propertyName + '!>';
			} else {
				return '';
			}
		}
	}



	self.strToBool = function(inData) {

		if (!inData) {
			return false;
		}

		switch (inData) {
			case 'false': return false; break;
			case 'true': return true; break;

			case 'no': return false; break;
			case 'yes': return true; break;

			case '0': return false; break;
			case '1': return true; break;
		}
	},

	self.getDateString = function(format, dateObj) {
		dateObj = dateObj || new Date();
		switch (format) {
			case 'dd_MMM_yyyy':
				//nodeJs apparently doesn't use the options parameter of toLocaleDateString()
				var outString = dateObj.toLocaleDateString('en-US').toString();
				outString = outString.replace(/^.*?, (\w+) (\d+), (\d+)$/, "$2_$1_$3");
				return outString;

				break;
			default:
				return dateObj.toLocaleDateString('en-US');
				break;
		}

	}

	self.parseCommandLine = function() {
		//process.argv
		var figureOutWhatItIs = function(filePath) {
			var isNotFile, trialString, statResult, fileString;

			try {
				var statResult = fs.statSync(filePath);
			} catch (err) {
				if (err && err.code == 'ENOENT') {
					isNotFile = true;
				} else if (err) {
					qtools.message("templateReplace.js says, ");
					qtools.die(err);
				}
			}

			if (statResult && statResult.isDirectory()) {
				fileString = filePath;
				isNotFile = true;
			}

			if (!isNotFile) {
				fileString = fs.readFileSync(filePath, 'utf8');
				if (fileString == '') {
					return '';
				}
			}

			if (typeof (fileString) != 'undefined') {
				trialString = fileString;
			} else {
				trialString = filePath;
			}

			if (isNotFile) {
				result = trialString;
			} else {
				result = fileString;
			}

			try {
				//example: (function(){ return {aaa:'bbb',ccc:'ddd'} })()
				//example: (function(item, inx, all){ return new Date(); }) //this one will be evaluated at substitution time
				result = eval(trialString);
			} catch (err) {
				if (cmdLineSwitches.v) {
					console.log('filePath=' + filePath + '\n');
					qtools.dump({
						'=-=== eval err =====': err
					});
				}
				try {
					var result = JSON.parse(trialString);
				} catch (err) {
					if (cmdLineSwitches.v) {
						qtools.dump({
							'=-=== JSON err =====': err
						});
					}
				}

			}

			return result;
		}


		var fileList = [],
			replaceObject = {},
			transformations = {},
			cmdLineSwitches = {};

		for (var i = 2, len = process.argv.length; i < len; i++) {
			var element = process.argv[i];

			if (element.match(/^--/)) {

				var explosion = element.match(/^--(\w+)=(.+)/);
				var replacement = figureOutWhatItIs(explosion[2]);

				if (replacement == '' && !cmdLineSwitches.q) {
					qtools.message(element + " is empty", 'red');
				}

				if (typeof (replacement) == 'number') {
					replaceObject[explosion[1]] = replacement.toString();
				} else if (typeof (replacement) == 'string') {
					replaceObject[explosion[1]] = replacement;
				} else if (qtools.toType(replacement) == 'object') {
					replaceObject = qtools.extend(replaceObject, replacement);
				} else if (typeof (replacement) == 'function') {
					transformations[explosion[1]] = replacement;
				} else {
					qtools.die(element + " produced a weird thing. Must yield either a string, function or an object");
				}


			} else if (element.match(/^-\w/)) {
				var explosion = element.match(/-(\w+)/);
				cmdLineSwitches[explosion[1]] = true;
			} else {
				fileList.push(element);
			}


		}

		return {
			fileList: fileList,
			values: replaceObject,
			functions: transformations,
			switches: cmdLineSwitches
		}

	}

	self.in = function(needle, haystack) {
		switch (self.toType(haystack)) {
			case 'array':
				return (haystack.indexOf(needle) > -1);
				break;
			case 'object':
				return (typeof (haystack[needle]) != 'undefined')
				break;
			case 'string':
				return (haystack.match(new RegExp(needle)) !== null)
				break;
			default:
				return false
				break;

		}
	}


	//FINALIZE ====================================
	return this;


};

//END OF moduleFunction() ============================================================
module.exports = moduleFunction;













